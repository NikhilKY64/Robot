#include <NewPing.h>
#include <Servo.h>
#include <AFMotor.h>

// ---------------- Pin Definitions ----------------
#define TRIGGER_PIN A1
#define ECHO_PIN    A0
#define MAX_DISTANCE 200

#define SERVO_PIN 10

// Motors (Adafruit Shield)
AF_DCMotor Motor1(1, MOTOR12_1KHZ);
AF_DCMotor Motor2(2, MOTOR12_1KHZ);
AF_DCMotor Motor3(3, MOTOR34_1KHZ);
AF_DCMotor Motor4(4, MOTOR34_1KHZ);

// ---------------- Adjustable Settings ----------------
#define FWD_SPEED 180       // slightly slower for stability
#define TURN_SPEED 150
#define OBSTACLE_DIST 20    // cm distance to stop
#define SERVO_LEFT 40       // points left
#define SERVO_RIGHT 140     // points right
#define SERVO_CENTER 90
#define PAUSE_TIME 500      // milliseconds pause at left/right
#define TOLERANCE 5         // cm difference to decide left/right

// ---------------- Globals ----------------
NewPing sonar(TRIGGER_PIN, ECHO_PIN, MAX_DISTANCE);
Servo myservo;

void setup() {
  Serial.begin(9600);
  myservo.attach(SERVO_PIN);
  myservo.write(SERVO_CENTER);
  randomSeed(analogRead(0)); // for random turns
}

// ---------------- Main Loop ----------------
void loop() {
  int frontDist = sonar.ping_cm();
  if(frontDist == 0) frontDist = MAX_DISTANCE;

  if(frontDist > OBSTACLE_DIST) {
    moveForward(FWD_SPEED);
  } else {
    stopMotors();
    delay(100);

    // Scan left
    myservo.write(SERVO_LEFT);
    delay(PAUSE_TIME + 200);
    int leftDist = sonar.ping_cm();
    if(leftDist == 0) leftDist = MAX_DISTANCE;

    // Scan right
    myservo.write(SERVO_RIGHT);
    delay(PAUSE_TIME + 200);
    int rightDist = sonar.ping_cm();
    if(rightDist == 0) rightDist = MAX_DISTANCE;

    // Return to center
    myservo.write(SERVO_CENTER);
    delay(200);

    // Decide turn direction
    if(leftDist > rightDist + TOLERANCE) {
      turnLeft(TURN_SPEED);     // turn away from obstacle
      delay(800);
    } 
    else if(rightDist > leftDist + TOLERANCE) {
      turnRight(TURN_SPEED);    // turn away from obstacle
      delay(800);
    } 
    else {
      // if equal distances, random turn
      moveBackward(FWD_SPEED);
      delay(300);
      if(random(0,2) == 0){
        turnLeft(TURN_SPEED);
      } else {
        turnRight(TURN_SPEED);
      }
      delay(600);
    }

    stopMotors();
  }

  delay(20); // small loop delay
}

// ---------------- Motor Helpers ----------------
void moveForward(int speed) {
  Motor1.setSpeed(speed); Motor1.run(FORWARD);
  Motor2.setSpeed(speed); Motor2.run(FORWARD);
  Motor3.setSpeed(speed); Motor3.run(FORWARD);
  Motor4.setSpeed(speed); Motor4.run(FORWARD);
}

void moveBackward(int speed){
  Motor1.setSpeed(speed); Motor1.run(BACKWARD);
  Motor2.setSpeed(speed); Motor2.run(BACKWARD);
  Motor3.setSpeed(speed); Motor3.run(BACKWARD);
  Motor4.setSpeed(speed); Motor4.run(BACKWARD);
}

// Corrected turn logic: turn away from obstacle
void turnLeft(int speed){
  Motor1.setSpeed(speed); Motor1.run(BACKWARD); // left wheels backward
  Motor2.setSpeed(speed); Motor2.run(BACKWARD);
  Motor3.setSpeed(speed); Motor3.run(FORWARD);  // right wheels forward
  Motor4.setSpeed(speed); Motor4.run(FORWARD);
}

void turnRight(int speed){
  Motor1.setSpeed(speed); Motor1.run(FORWARD);  // left wheels forward
  Motor2.setSpeed(speed); Motor2.run(FORWARD);
  Motor3.setSpeed(speed); Motor3.run(BACKWARD); // right wheels backward
  Motor4.setSpeed(speed); Motor4.run(BACKWARD);
}

void stopMotors(){
  Motor1.run(RELEASE);
  Motor2.run(RELEASE);
  Motor3.run(RELEASE);
  Motor4.run(RELEASE);
}
